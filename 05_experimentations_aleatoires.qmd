---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Expérimentations par assignation aléatoire

<iframe src="slides/fr/randomization.html" width="100%" height="400px">

</iframe>


<a href="slides/fr/randomization.html" download>Cliquer ici pour télécharger la présentation</a>.

## Mise en pratique

> **ATTENTION :** Il va de soi que les AP malgaches n'ont à aucun moment été assignées aléatoirement. Lors de cette séquence, on fait "comme si", pour montrer la manière dont les données sont analysées quand il y a eu assignation aléatoire. On verra en fin de session les limites d'une telle approche et dans les suivantes des manières de construire des contrefactuels plus vraisemblables pour un sujet comme celui-ci.

## Préparation des données

#Pour commencer, on charge les librairies requises (après les avoir installées si nécessaire).

```{r}
# On charge les librairies utiles pour cette analyse
library(tidyverse) # Facilite la manipulation de données
library(gt) # Aide à formater de jolis tableaux de rendu
library(broom) # Aide à formater les rendus de régressions
library(stargazer) # idem
library(sf) # Pour les données spatiales
library(lubridate) # Pour gérer des dates
library(htmltools)
library(mapme.biodiversity)
library(units)
library(lmtest)      # Tests statistiques sur des modèles linéaires (waldtest, coeftest)
library(sandwich)    # Calcul d'erreurs standards robustes (vcovHC pour heteroskedasticité)



# Désactiver les notations scientifiques
options(scipen = 999)

# On charge AP_Vahatra
AP_Vahatra <- read_rds("data/AP_Vahatra_mapme.rds")
```

## Analyse des équilibres initiaux

On commence par vérifier s'il existe des déséquilibres flagrants entre les aires qui ont été protégées avant 2015 et celles qui ont été protégées en 2015, en matière de surface totale ou de part couverte par des forêts en 2000.

```{r}

# # Correctly define variables with units
# AP_RCT <- AP_Vahatra %>%
#   portfolio_wide() %>% 
#   mutate(Groupe = ifelse(year(date_creation) < 2015, "Traitement", "Contrôle"),
#          `Couvert forestier en 2000` = `treecover_area_2000-01-01_treecover_ha`,
#          `Surface (ha)` = as.numeric(st_area(AP_Vahatra)) / 10000,
#          `Couvert forestier en 2000 (%)` = (`Couvert forestier en 2000` / `Surface (ha)`)*100)

# Définir les variables dans les bonnes unités
AP_RCT <- AP_Vahatra %>%
  # Supprimer les AP sans données de couvert forestier (souvent maritimes)
  filter(!map_lgl(treecover_area, is.null)) %>%
  
  mutate(
    Groupe = ifelse(year(date_creation) < 2015, "Traitement", "Contrôle"),
    Traitement = ifelse(Groupe == "Traitement", 1, 0),
    
    `Couvert forestier en 2000 (ha)` = map_dbl(treecover_area, ~ {
      val <- .x %>%
        filter(year(datetime) == 2000) %>%
        pull(value)
      if (length(val) == 0) NA_real_ else val[1]
    }),
    
     `Altitude moyenne (m)` = map_dbl(elevation, ~ {
      val <- .x %>%
        pull(value)
      if (length(val) == 0) NA_real_ else val[1]
    }),
    
    `Pente moyenne (degres)` = map_dbl(slope, ~ {
      val <- .x %>%
        pull(value)
      if (length(val) == 0) NA_real_ else val[1]
    }),
    
        `Temps de trajet (minutes)` = map_dbl(traveltime, ~ {
      val <- .x %>%
        pull(value)
      if (length(val) == 0) NA_real_ else val[1]
    }),
    
    `Surface (ha)` = as.numeric(st_area(.)) / 10000,
    
    `Couvert forestier en 2000 (%)` = (`Couvert forestier en 2000 (ha)` / `Surface (ha)`) * 100
  )


# Définir la fonction pour les étoiles de significativité
stars <- function(p) {
  if (is.na(p)) return("")
  if (p < 0.01) return("***")
  else if (p < 0.05) return("**")
  else if (p < 0.10) return("*")
  else return("")
}


# Liste des covariables à inclure dans le tableau d’équilibre
covars <- c("Surface (ha)", "Couvert forestier en 2000 (ha)", "Couvert forestier en 2000 (%)", "Altitude moyenne (m)", "Pente moyenne (degres)", "Temps de trajet (minutes)")

# Création du tableau d’équilibre
balance_data <- lapply(covars, function(var) {
    
      # Moyennes et écart-types par groupe
      stats <- AP_RCT %>%
        group_by(Groupe) %>%
        summarise(
          mean = mean(.data[[var]], na.rm = TRUE),
          sd = sd(.data[[var]], na.rm = TRUE),
          n = sum(!is.na(.data[[var]]))
        ) %>%
        ungroup()
    
      # Extraire les statistiques pour les deux groupes
      treat <- stats %>% filter(Groupe == "Traitement")
      control <- stats %>% filter(Groupe == "Contrôle")
      
      # Différence brute
      diff <- treat$mean - control$mean
      
      # Estimation de l’erreur standard via régression avec erreurs robustes
      mod <- lm(as.formula(paste0("`", var, "` ~ Groupe")), data = AP_RCT)
      coef_test <- coeftest(mod, vcov. = vcovHC(mod, type = "HC1"))
      se_diff <- coef_test["GroupeTraitement", "Std. Error"]
        p_val <- coef_test["GroupeTraitement", "Pr(>|t|)"]
        etoiles <- stars(p_val)
      
      # Calcul de la différence standardisée
      pooled_sd <- sqrt(0.5 * (treat$sd^2 + control$sd^2))
      std_diff <- diff / pooled_sd
    
  # Construction de la ligne du tableau
  tibble(
    Variable = var,
    Moy_Traitement = sprintf("%.2f\n(%.2f)", treat$mean, treat$sd),
    Moy_Contrôle = sprintf("%.2f\n(%.2f)", control$mean, control$sd),
    Diff = sprintf("%.2f%s\n[%.2f]", diff, etoiles, se_diff),
     Diff_std = sprintf("%.2f", std_diff) 
  )
}) %>% bind_rows()
  
  # Test de significativité conjointe des covariables (p-value du F-test)
  f_test_mod <- lm(as.formula(paste("Traitement ~", paste0("`", covars, "`", collapse = " + "))), data = AP_RCT)
  f_test <- waldtest(f_test_mod, vcov = vcovHC(f_test_mod, type = "HC1"))
  p_val_joint <- signif(f_test$`Pr(>F)`[2], 3)
  
  # Ajouter une ligne au tableau avec la p-value du F-test
  balance_data <- bind_rows(
    balance_data,
    tibble(
      Variable = "P-value F-test conjoint",
      Moy_Traitement = "", Moy_Contrôle = "",
      Diff = sprintf("p = %.3f", p_val_joint),
      Diff_std = ""
    )
  )

# Affichage final
balance_data %>%
  gt() %>%
  tab_header(
    title = "Tableau de contrôle d'équilibre initial entre groupes",
    subtitle = "(exercice : \"comme si\" c'était un RCT)"
  ) %>%
  cols_label(
    Variable = "Variable",
    Moy_Traitement = "Traitement\n(Moy (SD))",
    Moy_Contrôle = "Contrôle\n(Moy (SD))",
    Diff = "Différence\n(Moy [SE])",
    Diff_std = "Différence\nstandardisée"
  ) %>%
  tab_source_note("Source : Association Vahatra et données GFC")


```

> **Exercice** : Analysez le résultat de cette table.

En moyenne, les deux groupes sont assez proches en termes de surface et de couvert forestier, et le test de Student ne permet pas de rejeter l'hypothèse nulle concernant une différence de moyenne sur ces critères.

## Différences de déforestation "après intervention"

On va maintenant s'intéresser aux différences de déforestation observées "après intervention" dans le groupe de traitement, entre 2000 et 2014.

```{r}
# Calculer le taux annuel de déforestation moyen pour la période 2000-2014

AP_RCT <- AP_RCT %>%
  mutate(taux_deforestation_2000_2014 = 
           -((`treecover_area_2014-01-01_treecover_ha` - 
              `treecover_area_2000-01-01_treecover_ha`) /
           `treecover_area_2000-01-01_treecover_ha`)* 100)

# Comparer les taux de déforestation moyens entre les groupes
comparaison_deforestation <- AP_RCT %>%
  st_drop_geometry() %>%
  group_by(Groupe) %>%
  summarise(`Taux annuel de déforestation moyen 2000-2014 (%)` = 
              mean(taux_deforestation_2000_2014, na.rm = TRUE)) %>%
  mutate(across(!Groupe, ~round(., 2)))

# Ce qui suit est une série d'opérations pour formater le rendu en tableau
comparaison_deforestation %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column() %>%
  `colnames<-` (filter(., row_number() == 1)) %>%
  filter(row_number() != 1) %>%
  gt() %>%
  tab_header(title = "Moyennes des taux annuels de déforestation",
             subtitle = "(exercice : \"comme si\" c'était une RCT)") %>%
  tab_source_note("Source : Association Vahatra et données GFC")
```

> **Exercice** : Commentez le résultat de cette table.

On peut également réaliser une régression simple, qu'on présente selon le format courant pour la littérature en économie grâce au package {stargazer} [@hlavac2022].

```{r}
#| output: false

# On exécute une régression pour la période 2000-2014
def_2000_2014 <- lm(taux_deforestation_2000_2014 ~ Groupe, data = AP_RCT)

# On consolide les résultats des régressions dans une table qu'on formate
# avec le package stargazer
rct_out1 <- stargazer(def_2000_2014, type = "html",
          title = "Impact de la conservation sur la perte de couvert forestier",
          notes = "Données : Association Vahatra et données GFC")  
```
```{r, echo=FALSE}
# Cette commande s'imprime aussi bien dans RStudio que dans le rendu quarto
output_html <- browsable(HTML(paste(rct_out1, collapse = "")))
browsable(div(style = "width: 300px;", output_html))
```

> **Exercice** : Analysez le résultat de cette table. Qu'est-ce qu'elle suggère ?

## Analyse des variables topologiques et de l'accessibilité

On analyse ensuite la relation aux variables topologiques (altitude, pente) et de temps de trajet à la ville la plus proche en 2015. Le seuil retenu ici pour considérer une localité comme une ville est qu'elle ait au moins 5000 habitants.

```{r}
# On fait une série de tests de comparaison de moyenne pour les variables topologiques

t_tests_topo <- AP_RCT %>% 
  st_drop_geometry() %>%
  summarise(across(c(`elevation_2000-02-01_elevation_mean_m`, 
                   `slope_2000-02-01_slope_mean_degrees`, 
                   `traveltime_2015-01-01_5k_110mio_traveltime_mean_minutes`),
                   ~ t.test(as.numeric(.[Groupe == "Contrôle"]), as.numeric(.[Groupe == "Traitement"]))$p.value)) %>% 
  rename(`Altitude moyenne (m)` = `elevation_2000-02-01_elevation_mean_m`,
         `Pente moyenne (degrés)` = `slope_2000-02-01_slope_mean_degrees`,
         `Temps de trajet moyen (minutes)` = 
           `traveltime_2015-01-01_5k_110mio_traveltime_mean_minutes`) %>%
  mutate(Groupe = "t-test")

equilibre_topo <- AP_RCT %>%
  st_drop_geometry() %>%
  group_by(Groupe) %>%
  summarise(`Nombre d'aires` = n(),
            `Altitude moyenne (m)` = mean(`elevation_2000-02-01_elevation_mean_m`, na.rm = TRUE),
            `Pente moyenne (degrés)` = mean(`slope_2000-02-01_slope_mean_degrees`, na.rm = TRUE),
            `Temps de trajet moyen (minutes)` = mean(`traveltime_2015-01-01_5k_110mio_traveltime_mean_minutes`, na.rm = TRUE)) %>%
  bind_rows(t_tests_topo) %>% 
  mutate(across(!Groupe, ~round(., 2)))

# Ce qui suit est une série d'opérations pour formater le rendu en tableau
equilibre_topo %>%
  t() %>%
  as.data.frame() %>%
  tibble::rownames_to_column() %>%
  `colnames<-` (filter(., row_number() == 1)) %>%
  filter(row_number() != 1) %>%
  gt() %>%
  tab_header(title = "Équilibre entre les groupes en matière topologique",
             subtitle = "(exercice : \"comme si\" c'était une RCT)") %>%
  tab_source_note("Source : Nasa SRTM, Nelson et al.")
```

Le temps de trajet aux villes est significativement distinct entre les deux groupes. 

On essaye de limiter ce biais en ajoutant le temps de trajet à une ville comme variable de contrôle à notre régression.
```{r}
#| output: false
AP_RCT2 <- AP_RCT %>%
  rename(`Temps de trajet moyen (minutes)` = 
           `traveltime_2015-01-01_5k_110mio_traveltime_mean_minutes`)

# On exécute une régression pour la période 2000-2014
def_2000_2014 <- lm(taux_deforestation_2000_2014 ~ 
                      Groupe + `Temps de trajet moyen (minutes)`,
                    data = AP_RCT2)

# On consolide les résultats des régressions dans une table qu'on formate
# avec le package stargazer
rct_out2 <- stargazer(def_2000_2014, type = "html",
          title = "Impact de la conservation sur la perte de couvert forestier (en contrôlant pour l'accessibilité)",
          notes = "Données : Association Vahatra et données GFC")  
```
```{r, echo=FALSE}
# Cette commande s'imprime aussi bien dans RStudio que dans le rendu quarto
output2_html <- browsable(HTML(paste(rct_out2, collapse = "")))
browsable(div(style = "width: 500px;", output2_html))
```

> Exercice : interprétez le résultat